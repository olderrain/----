<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        // 3.5
        var myPow = function (x, n) {
            // let res = 1
            // const dfs = (res, n) => {
            //     if (n == 0) {
            //         return res
            //     }
            //     if (n > 0) {
            //         return dfs(res * x, n - 1)
            //     }
            //     if (n < 0) {
            //         return dfs(res / x, n + 1)
            //     }
            // }
            // return dfs(res, n)

            if (n == 0 || n == 1) {
                return n == 0 ? 1 : x
            } else if (n < 0) {
                return myPow(1 / x, Math.abs(n))
            } else {
                return n % 2 == 0 ? myPow(x * x, n / 2) : myPow(x * x, Math.floor(n / 2)) * x
            }
        };
        var insert = function (intervals, newInterval) {
            if (intervals.length == 0) {
                return [newInterval]
            }
            let n = intervals.length
            let l = newInterval[0]
            let r = newInterval[1]
            for (let i = 0; i < n; i++) {
                if (l <= intervals[i][0]) {
                    if (r >= intervals[i][1]) {
                        intervals[i] = null
                    } else if (r >= intervals[i][0] && r < intervals[i][1]) {
                        r = intervals[i][1]
                        intervals[i] = null
                    } else {
                        break
                    }
                } else if (l > intervals[i][0] && l <= intervals[i][1]) {
                    l = intervals[i][0]
                    if (r >= intervals[i][1]) {
                        intervals[i] = null
                    } else if (r >= intervals[i][0] && r < intervals[i][1]) {
                        r = intervals[i][1]
                        intervals[i] = null
                    }
                }
            }
            console.log(l, r, intervals);
            for (let i = 0; i < n; i++) {
                // if (i == n - 1 && intervals[i] == null) {
                //     intervals.push([l, r])
                //     break
                // }
                if (intervals[i] == null) continue
                if (l > intervals[i][1]) {
                    // if (i == n - 1) {
                    //     intervals.push([l, r])
                    //     break
                    // }
                    intervals[i + 1] = [l, r]
                    break
                }
                if (l < intervals[i][0]) {
                    if (i == 0) {
                        intervals.unshift([l, r])
                        break
                    }
                    intervals[i - 1] = [l, r]
                    break
                }
            }
            console.log(intervals);
            let slow = 0
            let fast = 0
            n = intervals.length
            while (fast < n) {
                if (intervals[fast] != null) {
                    intervals[slow] = intervals[fast]
                    slow++
                }
                fast++
            }
            return intervals.slice(0, slow)
        };
        var generateMatrix = function (n) {
            let direction = 'right'
            let matrix = new Array(n).fill(0).map(() => new Array(n).fill(0))
            let row = 0
            let col = 0
            let num = 1
            for (let i = 0; i < n / 2; i++) {
                if (direction == 'right') {
                    for (let j = i; j < n - i; j++) {
                        console.log(row, col);
                        matrix[row][col] = num
                        num++
                        if (col + 1 < n && matrix[row][col + 1] == 0) {
                            col++
                        }
                    }
                    direction = 'down'
                    row++
                }
                if (direction == 'down') {
                    for (let j = i; j < n - i - 1; j++) {
                        console.log(row, col);
                        matrix[row][col] = num
                        num++
                        if (row + 1 < n && matrix[row + 1][col] == 0) {
                            row++
                        }
                    }
                    direction = 'left'
                    col--
                }
                if (direction == 'left') {
                    for (let j = i; j < n - i - 1; j++) {
                        console.log(row, col);
                        matrix[row][col] = num
                        num++
                        if (col - 1 >= 0 && matrix[row][col - 1] == 0) {
                            col--
                        }
                    }
                    direction = 'up'
                    row--
                }
                if (direction == 'up') {
                    for (let j = i; j < n - i - 2; j++) {
                        console.log(row, col);
                        matrix[row][col] = num
                        num++
                        if (row - 1 >= 0 && matrix[row - 1][col] == 0) {
                            row--
                        }
                    }
                    direction = 'right'
                    col++
                }
                console.log(matrix);
            }
            console.log(matrix);

        };

        // 3.6
        var rotateRight = function (head, k) {
            if (k === 0 || !head || !head.next) {
                return head;
            }
            let n = 1;
            let cur = head;
            while (cur.next) {
                cur = cur.next;
                n++;
            }

            let add = n - k % n;
            if (add === n) {
                return head;
            }

            cur.next = head;
            while (add) {
                cur = cur.next;
                add--;
            }

            const ret = cur.next;
            cur.next = null;
            return ret;
        };
        var uniquePathsWithObstacles = function (obstacleGrid) {
            // 递归会超时 所以要用动态规划
            // if(obstacleGrid[0][0]==1){
            //     return 0
            // }
            // let n = obstacleGrid.length
            // let m = obstacleGrid[0].length
            // let pos = [0, 0]
            // let res = 0
            // const dfs = (pos) => {
            //     if (pos[0]==n-1&&pos[1]==m-1) {
            //         res++
            //         return
            //     }
            //     if (pos[0] + 1 < n && obstacleGrid[pos[0] + 1][pos[1]] != 1) {
            //         pos[0]++
            //         dfs(pos)
            //         pos[0]--
            //     }
            //     if (pos[1] + 1 < m && obstacleGrid[pos[0]][pos[1] + 1] != 1) {
            //         pos[1]++
            //         dfs(pos)
            //         pos[1]--
            //     }
            // }
            // dfs(pos)
            // return res
        };
        var minPathSum = function (grid) {
            let n = grid.length
            let m = grid[0].length
            let sum = new Array(n).fill(0).map(() => new Array(m).fill(0))
            sum[0][0] = grid[0][0]
            for (let i = 1; i < n; i++) {
                sum[i][0] = sum[i - 1][0] + grid[i][0]
            }
            for (let j = 1; j < m; j++) {
                sum[0][j] = sum[0][j - 1] + grid[0][j]
            }
            console.log(sum);
            for (let i = 1; i < n; i++) {
                for (let j = 1; j < m; j++) {
                    sum[i][j] = Math.min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j]
                }
            }
            return sum[n - 1][m - 1]
        };
        var addBinary = function (a, b) {
            let lena = a.length
            let lenb = b.length
            let len = Math.max(lena, lenb)
            let str = []
            let add = 0

            for (let i = 0; i < len; i++) {
                if (!a[lena - 1 - i]) {
                    if (parseInt(b[lenb - 1 - i]) + add == 0) {
                        str.unshift('0')
                        add = 0
                    } else if (parseInt(b[lenb - 1 - i]) + add == 1) {
                        str.unshift('1')
                        add = 0
                    } else if (parseInt(b[lenb - 1 - i]) + add == 2) {
                        str.unshift('0')
                        add = 1
                    }
                } else if (!b[lenb - 1 - i]) {
                    if (parseInt(a[lena - 1 - i]) + add == 0) {
                        str.unshift('0')
                        add = 0
                    } else if (parseInt(a[lena - 1 - i]) + add == 1) {
                        str.unshift('1')
                        add = 0
                    } else if (parseInt(a[lena - 1 - i]) + add == 2) {
                        str.unshift('0')
                        add = 1
                    }
                } else {
                    if (parseInt(a[lena - 1 - i]) + parseInt(b[lenb - 1 - i]) + add == 0) {
                        str.unshift('0')
                        add = 0
                    } else if (parseInt(a[lena - 1 - i]) + parseInt(b[lenb - 1 - i]) + add == 1) {
                        str.unshift('1')
                        add = 0
                    } else if (parseInt(a[lena - 1 - i]) + parseInt(b[lenb - 1 - i]) + add == 2) {
                        str.unshift('0')
                        add = 1
                    } else if (parseInt(a[lena - 1 - i]) + parseInt(b[lenb - 1 - i]) + add == 3) {
                        str.unshift('1')
                        add = 1
                    }
                }
                if (add == 1 && i == len - 1) {
                    str.unshift('1')
                }
            }
            return str.join('')
        };
        var mySqrt = function (x) {
            // if(x==0)return 0
            // if(x<4)return 1
            // let num=2
            // while(x>=num*num){
            //     if(num*num==x||(num+1)*(num+1)>x){
            //         return num
            //     }
            //     num++
            // }
            // return num

            let l = 1
            let r = x
            while (l <= r) {
                let mid = Math.floor((l + r) / 2)
                if (mid * mid <= x) {
                    if ((mid + 1) * (mid + 1) > x) {
                        return mid
                    } else {
                        l = mid
                    }
                } else {
                    r = mid
                }
            }
        };
        // 3.7
        var simplifyPath = function (path) {
            // 过不了 放弃
            // if (path[0] != '/') return null
            // let arr = path.split('/')
            // let n = arr.length
            // console.log(arr);
            // for (let i = 0; i < n; i++) {
            //     if(arr[i]=='.'){
            //         arr[i]=''
            //     }
            //     if(arr[i]=='..'){
            //         arr[i]=''
            //         for(let j=i-1;j>=0;j--){
            //             if(arr[j]!=''){
            //                 arr[j]=''
            //                 break
            //             }
            //         }
            //     }
            // }
            // let flag=false
            // for(let i=0;i<n;i++){
            //     if(arr[i]!=''){
            //         flag=true
            //     }
            // }
            // if(flag==false){
            //     return '/'
            // }
            // console.log(arr);
            // for (let i = 0; i < n ; i++) {
            //     if(i==n-1&&arr[i]==''){
            //         break
            //     }                
            //     if (arr[i] != '' && arr[i + 1] != '') {
            //         arr.splice(i + 1, 0, '/')
            //         i++
            //     }
            //     if (arr[i] == '' && arr[i + 1] != '') {
            //         arr[i] = '/'
            //     }
            // }
            // return arr.join('')
            var simplifyPath = function (path) {
                const names = path.split("/");
                const stack = [];
                for (const name of names) {
                    if (name === "..") {
                        if (stack.length) {
                            stack.pop();
                        }
                    } else if (name.length && name !== ".") {
                        stack.push(name);

                    }
                }

                return "/" + stack.join("/");
            };
        };
        var minDistance = function (word1, word2) {
            let n = word1.length
            let m = word2.length
            if (n == 0) return m
            if (m == 0) return n
            let dp = new Array(n + 1).fill(0).map(() => new Array(m + 1).fill(0))
            for (let i = 0; i <= n; i++) {
                dp[i][0] = i
            }
            for (let j = 0; j <= m; j++) {
                dp[0][j] = j
            }
            for (let i = 1; i <= n; i++) {
                for (let j = 1; j <= m; j++) {
                    if (word1[i - 1] == word2[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1]
                    } else {
                        dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                    }
                }
            }
            console.log(dp);
            return dp[n][m]
        };
        var searchMatrix = function (matrix, target) {
            let n = matrix.length
            let m = matrix[0].length
            let l = -1
            let r = n - 1
            let mid = 0
            while (l < r) {
                mid = Math.floor((r - l + 1) / 2) + l
                if (matrix[mid][0] == target) {
                    return true
                } else if (matrix[mid][0] < target) {
                    l = mid
                } else {
                    r = mid - 1
                }
            }
            let row = l
            l = -1
            r = m - 1
            while (l < r) {
                mid = Math.floor((r - l) / 2) + l
                if (matrix[row][mid] == target) {
                    return true
                } else if (matrix[row][mid] < target) {
                    l = mid
                } else {
                    r = mid - 1
                }
            }
            return false
        };
        // 3.8
        var sortColors = function (nums) {
            let n = nums.length
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i; j++) {
                    if (nums[j] > nums[j + 1]) {
                        let temp = nums[j]
                        nums[j] = nums[j + 1]
                        nums[j + 1] = temp
                    }
                }
            }
            return nums
        };
        var combine = function (n, k) {
            let result = []
            let path = []
            const combineHelper = (n, k, startIndex) => {
                if (path.length === k) {
                    result.push([...path])
                    return
                }
                for (let i = startIndex; i <= n - (k - path.length) + 1; ++i) {
                    path.push(i)
                    combineHelper(n, k, i + 1)
                    path.pop()
                }
            };
            combineHelper(n, k, 1)
            return result
        }
        var exist = function (board, word) {
            let n = board.length
            let m = board[0].length
            let w = word.length
            let row = 0
            let col = 0
            let flag = false
            let use = new Array(n).fill(0).map(() => new Array(m).fill(0))
            const dfs = (cur, row, col) => {
                if (flag == true) {
                    return
                }
                if (cur == w - 1 && board[row][col] == word[cur]) {
                    flag = true
                    return
                }
                if (board[row][col] != word[cur]) {
                    return
                }
                if (board[row][col] == word[cur]) {
                    use[row][col] = 1
                    if (row - 1 >= 0 && use[row - 1][col] == 0) {
                        dfs(cur + 1, row - 1, col)
                    }
                    if (row + 1 < n && use[row + 1][col] == 0) {
                        dfs(cur + 1, row + 1, col)
                    }
                    if (col - 1 >= 0 && use[row][col - 1] == 0) {
                        dfs(cur + 1, row, col - 1)
                    }
                    if (col + 1 < m && use[row][col + 1] == 0) {
                        dfs(cur + 1, row, col + 1)
                    }
                    use[row][col] = 0
                }

            }
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < m; j++) {
                    if (board[i][j] == word[0]) {
                        dfs(0, i, j)
                    }
                }
            }
            return flag
        };
        var removeDuplicates = function (nums) {
            let n = nums.length
            if (n <= 2) {
                return
            }
            let slow = 2
            let fast = 2
            while (fast < n) {
                if (nums[slow - 2] == nums[fast]) {
                    nums[slow] = nums[fast]
                    ++slow
                }
                ++fast
            }
            return slow
        };
        // 3.9
        var longestConsecutive = function (nums) {
            // let n=nums.length
            // nums.sort((a,b)=>a-b)
            // let max=1
            // let count=1
            // for(let i=0;i<n;i++){
            //     if(nums[i]==nums[i+1]){
            //         continue
            //     }
            //     if(nums[i]+1==nums[i+1]){
            //         count++
            //     }else{
            //         count=1
            //     }
            //     max=Math.max(max,count)
            // }
            // return max

            let n = nums.length
            let s = new Set(nums)
            let max = 0
            for (let i = 0; i < n; i++) {
                if (!s.has(nums[i] - 1)) {
                    let cur = nums[i]
                    let count = 1
                    while (s.has(cur + 1)) {
                        cur++
                        count++
                    }
                    max = Math.max(max, count)
                }
            }
            return max
        };
        var moveZeroes = function (nums) {
            let n = nums.length
            let slow = 0
            let fast = 0
            while (fast < n) {
                if (nums[fast] != 0) {
                    nums[slow] = nums[fast]
                    slow++
                }
                fast++
            }
            // console.log(slow);
            for (let i = slow; i < n; i++) {
                nums[i] = 0
            }
            return nums
        };
        var findAnagrams = function (s, p) {
            let slen = s.length
            let plen = p.length
            let scount = new Array(26).fill(0)
            let pcount = new Array(26).fill(0)
            let res = []
            if (slen < plen) {
                return []
            }
            for (let i = 0; i < plen; i++) {
                ++scount[s[i].charCodeAt() - 'a'.charCodeAt()]
                ++pcount[p[i].charCodeAt() - 'a'.charCodeAt()]
            }
            if (scount.toString() == pcount.toString()) {
                res.push(0)
            }
            for (let i = 0; i < slen - plen; i++) {
                --scount[s[i].charCodeAt() - 'a'.charCodeAt()]
                ++scount[s[i + plen].charCodeAt() - 'a'.charCodeAt()]
                if (scount.toString() == pcount.toString()) {
                    console.log(1);
                    res.push(i + 1)
                }
            }
            return res
        };
        var subarraySum = function (nums, k) {
            // let n = nums.length
            // let res = 0
            // let subn = 1
            // for (let i = 0; i < n; i++) {
            //     subn = 1
            //     let sum = nums[i]
            //     if(sum==k){
            //         res++
            //     }
            //     while (i + subn < n) {
            //         sum += nums[i + subn]
            //         subn++
            //         if (sum == k) {
            //             res++
            //         }
            //     }


            // }
            // return res

            let n = nums.length
            let res = 0
            for (let i = 0; i < n; i++) {
                let sum = 0;
                for (let j = i; j < n; j++) {
                    sum += nums[j];
                    if (sum == k) res++;
                }
            }
            return res
        };
        var rotate = function (nums, k) {
            let arr1 = new Array()
            let arr2 = new Array()
            for (let i = 0; i < nums.length - k; i++) {
                arr1.push(nums[i])
            }
            for (let i = nums.length - 1; i >= nums.length - k; i--) {
                arr2.unshift(nums[i])
            }
            nums = [...arr2, ...arr1]
            return nums
        };
        // 3.10
        var productExceptSelf = function (nums) {
            let n = nums.length
            let answer = new Array(n).fill(1)
            let larr = []
            let rarr = []
            larr[0] = 1
            rarr[n - 1] = 1
            for (let i = 1; i < n; i++) {
                larr[i] = larr[i - 1] * nums[i - 1]
            }
            for (let i = n - 2; i >= 0; i--) {
                rarr[i] = rarr[i + 1] * nums[i + 1]
            }
            for (let i = 0; i < n; i++) {
                answer[i] = larr[i] * rarr[i]
            }
            return answer
        };
        var searchMatrix = function (matrix, target) {
            let n = matrix.length
            let m = matrix[0].length
            let l = 0
            let r = m - 1
            let mid = 0
            for (let i = 0; i < n; i++) {
                l = 0
                r = m - 1
                while (l <= r) {
                    mid = Math.floor((r - l) / 2) + l
                    if (matrix[i][mid] == target) {
                        return true
                    } else if (matrix[i][mid] < target) {
                        l = mid + 1
                    } else {
                        r = mid - 1
                    }
                }
            }
            return false

        };
        // 五个链表题...
        // 两个二叉树
        var maxProfit = function (prices) {
            // 超时
            // let n = prices.length
            // let max = 0
            // for (let i = 0; i < n; i++) {
            //     for (let j = i + 1; j < n; j++) {
            //         max=Math.max(max,prices[j]-prices[i])
            //     }
            // }
            // return max

            let n = prices.length
            let maxProfit = 0
            let maxPrice = prices[n - 1]
            for (let i = n - 2; i >= 0; i--) {
                maxProfit = Math.max(maxProfit, maxPrice - prices[i])
                maxPrice = Math.max(maxPrice, prices[i])
            }
            return maxProfit
        };
        var isPerfectSquare = function (num) {
            let left = 1
            let right = num
            while (left <= right) {
                x = Math.floor((right - left) / 2) + left
                if (x * x == num) {
                    return true
                } else if (x * x < num) {
                    left = x + 1
                } else {
                    right = x - 1
                }

            }
            return false
        };
        // 3.11
        var backspaceCompare = function (s, t) {
            let n = s.length
            let m = t.length
            let i = n - 1
            let j = m - 1
            let skeps = 0
            let skept = 0
            while (i >= 0 || j >= 0) {

                while (i >= 0) {
                    if (s[i] == '#') {
                        skeps++
                        i--
                    } else if (skeps > 0) {
                        skeps--
                        i--
                    } else {
                        break
                    }
                }

                while (j >= 0) {
                    if (t[j] == '#') {
                        skept++
                        j--
                    } else if (skept > 0) {
                        skept--
                        j--
                    } else {
                        break
                    }
                }
                if (i >= 0 && j >= 0) {
                    if (s[i] != t[j]) {
                        return false;
                    }
                } else {
                    if (i >= 0 || j >= 0) {
                        return false
                    }
                }
                i--
                j--
            }
            return true
        };
        var sortedSquares = function (nums) {
            // let n=nums.length
            // for(let i=0;i<n;i++){
            //     nums[i]=nums[i]*nums[i]
            // }
            // nums.sort((a,b)=>a-b)
            // return nums
            let n = nums.length
            let res = new Array(n).fill(0)
            let k = n - 1
            let i = 0
            let j = n - 1
            while (i <= j) {
                if (nums[i] * nums[i] < nums[j] * nums[j]) {
                    res[k] = nums[j] * nums[j]
                    j--

                } else {
                    res[k] = nums[i] * nums[i]
                    i++
                }
                k--
            }
            return res
        };
        var minSubArrayLen = function (target, nums) {
            // let n = nums.length
            // let min = 100000
            // for (let i = 0; i < n; i++) {
            //     let sum = nums[i]
            //     if (sum >= target) {
            //         min = Math.min(min, 1)
            //         break
            //     }
            //     for (let j = i + 1; j < n; j++) {
            //         sum += nums[j]
            //         if (sum >= target) {
            //             min = Math.min(min, j - i + 1)
            //             break
            //         }
            //     }
            // }
            // return min==100000?0:min

            let sum = 0
            let n = nums.length
            let res = n + 1
            let i = 0
            let subLength = 0
            for (let j = 0; j < n; j++) {
                sum += nums[j]
                while (sum >= target) {
                    subLength = j - i + 1
                    res = Math.min(res, subLength)
                    sum -= nums[i]
                    i++
                }
            }
            return res == n + 1 ? 0 : res
        };
        // 3.12
        var totalFruit = function (fruits) {
            // 超时
            // let n=fruits.length
            // if(n<2){
            //     return n
            // }
            // let fruitj=-1
            // let res=0
            // let once=0
            // for(let i=0;i<n;i++){
            //     for(let j=i+1;j<n;j++){      
            //         console.log(i,j);  
            //         if(fruits[i]!=fruits[j]&&once==0){
            //             fruitj=fruits[j]
            //             once=1
            //         }
            //         if(fruits[j]!=fruits[i]&&fruits[j]!=fruitj){
            //             res=Math.max(res,j-i)
            //             break
            //         }
            //         if(j==n-1){
            //             res=Math.max(res,j-i+1)
            //         }
            //     }
            //     once=0
            // }
            // return res

            let n = fruits.length
            let i = 0
            let res = 0
            let m = new Map()
            for (let j = 0; j < n; j++) {
                m.set(fruits[j], (m.get(fruits[j]) || 0) + 1)
                while (m.size > 2) {
                    m.set(fruits[i], m.get(fruits[i]) - 1)
                    if (m.get(fruits[i]) == 0) {
                        m.delete(fruits[i])
                    }
                    i++
                }
                res = Math.max(res, j - i + 1)
            }
            return res
        };
        var minWindow = function (s, t) {
            let n = s.length
            let nt = t.length
            let m = new Map()
            let str = []
            let beforestr = new Array(100000).fill(0)
            let left = 0
            let flag
            for (let i = 0; i < nt; i++) {
                m.set(t[i], (m.get(t[i]) || 0) + 1)
            }
            let m2 = new Map([...m.entries()])
            for (let right = 0; right < n; right++) {
                m.set(s[right], (m.get(s[right]) || 0) - 1)
                str.push(s[right])
                flag = true
                if (m.get(s[right]) <= 0) {
                    m.forEach((value, key) => {
                        if (value > 0) {
                            flag = false
                        }
                    })
                } else {
                    flag = false
                }
                if (flag) {
                    if (str.length < beforestr.length) {
                        beforestr = [...str]
                    }
                    while (flag) {
                        m.set(s[left], m.get(s[left]) + 1)
                        if (m.get(s[left]) > 0) {
                            flag = false
                            if (str.length < beforestr.length) {
                                beforestr = [...str]
                            }
                        }
                        left++
                        str.shift()
                    }
                }
            }
            return beforestr.length == 100000 ? '' : beforestr.join('')
        };
        // 3.13
        // 三个链表题
        // 3.14
        // 一个链表题
        var isAnagram = function (s, t) {
            let m = new Map()
            let ns = s.length
            let nt = t.length
            if (ns != nt) {
                return false
            }
            for (let i = 0; i < ns; i++) {
                m.set(s[i], (m.get(s[i]) || 0) + 1)
            }
            for (let i = 0; i < nt; i++) {
                m.set(t[i], (m.get(t[i]) || 0) - 1)
            }
            let flag = true
            m.forEach((value, key) => {
                if (value != 0) {
                    flag = false
                }
            })
            return flag
        };
        var canConstruct = function (ransomNote, magazine) {
            let n1 = ransomNote.length
            let n2 = magazine.length
            let m = new Map()
            for (let i = 0; i < n2; i++) {
                m.set(magazine[i], (m.get(magazine[i]) || 0) + 1)
            }
            for (let i = 0; i < n1; i++) {
                m.set(ransomNote[i], (m.get(ransomNote[i]) || 0) - 1)
                if (m.get(ransomNote[i]) < 0) {
                    return false
                }
            }
            return true
        };
        var intersection = function (nums1, nums2) {
            let n1 = nums1.length
            let n2 = nums2.length
            let s = new Set(nums1)
            let res = new Set()
            for (let i = 0; i < n2; i++) {
                if (s.has(nums2[i])) {
                    res.add(nums2[i])
                }
            }
            return Array.from(res)
        };
        var intersect = function (nums1, nums2) {
            let n1 = nums1.length
            let n2 = nums2.length
            let m = new Map()
            let res = new Array()
            for (let i = 0; i < n1; i++) {
                m.set(nums1[i], (m.get(nums1[i]) || 0) + 1)
            }
            for (let i = 0; i < n2; i++) {
                if (m.get(nums2[i]) > 0) {
                    res.push(nums2[i])
                    m.set(nums2[i], (m.get(nums2[i]) || 0) - 1)
                }
            }
            return res
        };
        var isHappy = function (n) {
            let set = new Set()
            let arr = new Array()
            while (!set.has(n)) {
                set.add(n)
                if (n == 1) {
                    return true
                }
                arr = []
                while (n > 0) {
                    arr.push(n % 10)
                    n = Math.floor(n / 10)
                }
                for (let num of arr) {
                    n += num * num
                }
            }
            return false
        };
        var fourSumCount = function (nums1, nums2, nums3, nums4) {
            let twoSumMap = new Map()
            let count = 0
            for (const n1 of nums1) {
                for (const n2 of nums2) {
                    const sum = n1 + n2
                    twoSumMap.set(sum, (twoSumMap.get(sum) || 0) + 1)
                }
            }
            for (const n3 of nums3) {
                for (const n4 of nums4) {
                    const sum = n3 + n4
                    count += twoSumMap.get(0 - sum) || 0
                }
            }
            return count
        };
        var reverseString = function (s) {
            let n = s.length
            for (let i = 0; i < n / 2; i++) {
                [s[i], s[n - 1 - i]] = [s[n - 1 - i], s[i]]
            }
            return s
        };
        var reverseStr = function (s, k) {
            let n = s.length
            s = s.split('')
            for (let i = 0; i < n;) {
                if (n - i < k) {
                    for (let j = i; j < (n + i) / 2; j++) {
                        [s[j], s[n - j - 1 + i]] = [s[n - j - 1 + i], s[j]]
                    }
                    break
                }
                for (let j = i; j < (i + k + i) / 2; j++) {
                    [s[j], s[i + k - j - 1 + i]] = [s[i + k - j - 1 + i], s[j]]
                }
                i += k * 2
            }
            return s.join('')
        };
        // 3.15
        var reverseWords = function (s) {
            s = s.split(' ')
            let n = s.length
            for (let i = 0; i < n / 2; i++) {
                [s[i], s[n - i - 1]] = [s[n - i - 1], s[i]]
            }
            let slow = 0
            let fast = 0
            while (fast < n) {
                if (s[fast] != '') {
                    s[slow] = s[fast]
                    slow++
                }
                fast++
            }
            return s.slice(0, slow).join(' ')
        };
        var repeatedSubstringPattern = function (s) {
            let n = s.length
            let PI = new Array(n)
            PI[0] = 0
            for (let i = 1; i < n; i++) {
                let j = PI[i - 1]
                while (j > 0 && s[i] != s[j]) {
                    j = PI[j - 1]
                }
                if (s[i] == s[j]) {
                    j++
                }
                PI[i] = j
            }
            if (PI[n - 1] != 0 && n % (n - PI[n - 1]) == 0) {
                return true
            }
            return false
        };
        // 3.16
        var removeDuplicates = function (s) {
            let stack = []
            let n = s.length
            for (let i = 0; i < n; i++) {
                if (stack[stack.length - 1] == s[i]) {
                    stack.pop()
                    continue
                } else {
                    stack.push(s[i])
                }
            }
            return stack.join('')
        };
        var evalRPN = function (tokens) {
            // 自己写的不优雅
            // let stack = []
            // let n = tokens.length
            // for (let i = 0; i < n; i++) {
            //     stack.push(tokens[i])
            //     console.log(stack);
            //     if (tokens[i] == '+') {
            //         stack[stack.length - 3] = parseInt(stack[stack.length - 3]) + parseInt(stack[stack.length - 2])
            //         stack.pop()
            //         stack.pop()
            //     } else if (tokens[i] == '-') {
            //         stack[stack.length - 3] = parseInt(stack[stack.length - 3]) - parseInt(stack[stack.length - 2])
            //         stack.pop()
            //         stack.pop()
            //     } else if (tokens[i] == '*') {
            //         stack[stack.length - 3] = parseInt(stack[stack.length - 3]) * parseInt(stack[stack.length - 2])
            //         stack.pop()
            //         stack.pop()
            //     } else if (tokens[i] == '/') {
            //         if (parseInt(stack[stack.length - 3]) / parseInt(stack[stack.length - 2]) < 0) {
            //             stack[stack.length - 3] = Math.ceil(parseInt(stack[stack.length - 3]) / parseInt(stack[stack.length - 2]))
            //         } else {
            //             stack[stack.length - 3] = Math.floor(parseInt(stack[stack.length - 3]) / parseInt(stack[stack.length - 2]))
            //         }
            //         stack.pop()
            //         stack.pop()
            //     }
            // }
            // return stack

            // 优雅
            const stack = [];
            for (const token of tokens) {
                if (isNaN(Number(token))) { // 非数字
                    const n2 = stack.pop(); // 出栈两个数字
                    const n1 = stack.pop();
                    switch (token) { // 判断运算符类型，算出新数入栈
                        case "+":
                            stack.push(n1 + n2);
                            break;
                        case "-":
                            stack.push(n1 - n2);
                            break;
                        case "*":
                            stack.push(n1 * n2);
                            break;
                        case "/":
                            stack.push(n1 / n2 | 0);
                            break;
                    }
                } else { // 数字
                    stack.push(Number(token));
                }
            }
            return stack[0]; // 因没有遇到运算符而待在栈中的结果
        };
        var maxSlidingWindow = function (nums, k) {
            // 自己创建一个队列来实现
            // 我抄答案了
        };
        var topKFrequent = function (nums, k) {
            let m = new Map()
            let n = nums.length
            for (let i = 0; i < n; i++) {
                m.set(nums[i], (m.get(nums[i]) || 0) + 1)
            }
            return [...m.entries()].sort((a, b) => b[1] - a[1]).slice(0, k).map(i => i[0])
        };
        // 二叉树的前序遍历
        // 二叉树的后序遍历
        // n个二叉树
        // 反正3.16一共16个题
        // 3.17
        // 一共9个题
        // 3.18
        // 一共11个题
        // 3.19
        // 一个二叉树
        var combinationSum3 = function (k, n) {
            let combinations = []
            let combination = []
            let backTrack = (sum, start) => {
                if (combination.length == k) {
                    if (sum == n) {
                        combinations.push([...combination])
                    }
                    return
                }
                for (let i = start; i <= 9; i++) {
                    combination.push(i)
                    backTrack(sum + i, i + 1)
                    combination.pop()
                }
            }
            backTrack(0, 1)
            return combinations
        };
        var partition = function (s) {
            const huiwen = (arr) => {
                let n1 = arr.length
                if (n1 == 0) return false
                if (n1 == 1) return true
                for (let i = 0; i < n1 / 2; i++) {
                    if (arr[i] != arr[n1 - 1 - i]) {
                        return false
                    }
                }
                return true
            }
            let n = s.length
            let res = []
            let str = []
            const backTrack = (start) => {
                if (start == n) {
                    for (let i = 0; i < str.length; i++) {
                        if (!huiwen(str[i])) {
                            return
                        }
                    }
                    res.push([...str])
                    return
                }
                for (let i = start; i < n; i++) {
                    str.push(s.slice(start, i + 1))
                    backTrack(i + 1)
                    str.pop()
                }
            }
            backTrack(0)
            return res
        };
        var restoreIpAddresses = function (s) {
            let res = []
            let ip = []
            let n = s.length
            const backTrack = (start) => {
                if (ip.length > 4) {
                    return
                }
                if (ip.length == 4 && start == n) {
                    res.push(ip.join('.'))
                    return
                }
                for (let i = start; i < n; i++) {
                    let str = s.slice(start, i + 1)
                    if (str.length > 3 || +str > 255) break;
                    if (str.length > 1 && str[0] === "0") break;
                    ip.push(str)
                    backTrack(i + 1)
                    ip.pop()
                }
            }
            backTrack(0)
            return res
        };
        var subsetsWithDup = function (nums) {
            let n = nums.length
            let res = []
            let combination = []
            nums.sort((a, b) => a - b)
            const backTrack = (start) => {
                if (start > n) {
                    return
                }
                res.push([...combination])
                for (let i = start; i < n; i++) {
                    if (i > start && nums[i] == nums[i - 1]) continue
                    combination.push(nums[i])
                    backTrack(i + 1)
                    combination.pop()
                }
            }
            backTrack(0)
            return res
        };
        var findSubsequences = function (nums) {
            let n = nums.length
            let res = []
            let sub = []
            const backTrack = (start) => {
                if (sub.length >= 2) {
                    res.push([...sub])
                }
                let used = []
                for (let i = start; i < n; i++) {
                    if ((sub.length > 0 && nums[i] < sub[sub.length - 1]) || used[nums[i]]) {
                        continue
                    } else {
                        used[nums[i]] = true
                        sub.push(nums[i])
                        backTrack(i + 1)
                        sub.pop()
                    }
                }
            }
            backTrack(0)
            return res
        };
        // 3.20
        var findItinerary = function (tickets) {
            let n = tickets.length
            let res = ['JFK']
            let map = {}
            for (let i = 0; i < n; i++) {
                const [from, to] = tickets[i]
                if (!map[from]) {
                    map[from] = []
                }
                map[from].push(to)
            }
            for (const city in map) {
                // 对到达城市列表排序
                map[city].sort()
            }
            let backTrack = () => {
                if (res.length == n + 1) {
                    return true
                }
                if (!map[res[res.length - 1]] || !map[res[res.length - 1]].length) return false
                for (let i = 0; i < map[res[res.length - 1]].length; i++) {
                    let to = map[res[res.length - 1]][i]
                    map[res[res.length - 1]].splice(i, 1)
                    res.push(to)
                    if (backTrack()) return true
                    res.pop()
                    map[res[res.length - 1]].splice(i, 0, to)
                }

            }
            backTrack('JFK')
            return res
        };
        var findContentChildren = function (g, s) {
            g.sort((a, b) => a - b)
            s.sort((a, b) => a - b)
            let i = 0
            let j = 0
            let res = 0
            console.log(g, s);
            while (j < s.length) {
                if (s[j] >= g[i]) {
                    res++
                    i++
                    j++
                } else {
                    j++
                }
            }
            return res
        };
        var wiggleMaxLength = function (nums) {
            let n = nums.length
            if (n < 2) return n
            if (n == 2) {
                if (nums[1] - nums[0] == 0) {
                    return 1
                }
            }
            let prediff = 0
            let curdiff = 0
            let res = 1
            for (let i = 0; i < n - 1; i++) {
                curdiff = nums[i + 1] - nums[i]
                if (curdiff == 0 || (prediff < 0 && curdiff < 0) || (prediff > 0 && curdiff > 0)) {
                    continue
                }
                res++
                prediff = curdiff
            }
            return res
        };
        var maxProfit = function (prices) {
            let profit = 0
            let n = prices.length
            for (let i = 1; i < n; i++) {
                if (prices[i] > prices[i - 1]) {
                    profit += prices[i] - prices[i - 1]
                }
            }
            return profit
        };
        // 3.21
        var largestSumAfterKNegations = function (nums, k) {
            nums.sort((a, b) => a - b)
            let n = nums.length
            let sum = 0
            for (let i = 0; i < n; i++) {
                if (k > 0) {
                    if (nums[i] < 0) {
                        k--
                        nums[i] = 0 - nums[i]
                        if (k % 2 != 0 && i == n - 1) {
                            nums[i] = 0 - nums[i]
                        }
                    } else {
                        if (k % 2 != 0) {
                            if (i == 0) {
                                nums[i] = 0 - nums[i]
                            } else {
                                if (nums[i] < nums[i - 1]) {
                                    nums[i] = 0 - nums[i]
                                } else {
                                    sum -= nums[i - 1] * 2
                                    nums[i - 1] = 0 - nums[i - 1]
                                }
                            }
                        }
                        k = 0
                    }
                }
                sum += nums[i]
            }
            return sum
        };
        var canCompleteCircuit = function (gas, cost) {
            // 超时
            // let n = gas.length
            // let g = []
            // for (let i = 0; i < n; i++) {
            //     if (gas[i] >= cost[i]) {
            //         g = 0
            //         for (let j = 0; j < n; j++) {
            //             let k = (i + j) % n
            //             g += gas[k] - cost[k]
            //             console.log(g);
            //             if (g < 0) {
            //                 break
            //             }
            //         }
            //         if (g >= 0) {
            //             return i
            //         }
            //     }
            // }
            // return -1

            let curSum = 0
            let min = Infinity
            for (let i = 0; i < gas.length; i++) {
                let rest = gas[i] - cost[i]
                curSum += rest
                if (curSum < min) {
                    min = curSum
                }
            }
            if (curSum < 0) return -1   //1.总油量 小于 总消耗量
            if (min >= 0) return 0      //2. 说明油箱里油没断过
            //3. 从后向前，看哪个节点能这个负数填平，能把这个负数填平的节点就是出发节点
            for (let i = gas.length - 1; i >= 0; i--) {
                let rest = gas[i] - cost[i]
                min += rest
                if (min >= 0) {
                    return i
                }
            }
            return -1
        };
        var candy = function (ratings) {
            let n = ratings.length
            let can = new Array(n).fill(1)
            for (let i = 1; i < n; i++) {
                if (ratings[i] > ratings[i - 1]) {
                    can[i] = can[i - 1] + 1
                }
            }
            for (let i = n - 2; i >= 0; i--) {
                if (ratings[i] > ratings[i + 1]) {
                    can[i] = Math.max(can[i], can[i + 1] + 1)
                }
            }
            let sum = 0
            for (let i = 0; i < n; i++) {
                sum += can[i]
            }
            return sum
        };
        var lemonadeChange = function (bills) {
            let n = bills.length
            let map = new Map()
            for (let i = 0; i < n; i++) {
                if (bills[i] == 5) {
                    map.set(5, (map.get(5) || 0) + 1)
                } else if (bills[i] == 10) {
                    map.set(10, (map.get(10) || 0) + 1)
                    if (map.get(5) > 0) {
                        map.set(5, (map.get(5) || 0) - 1)
                    } else {
                        return false
                    }
                } else if (bills[i] == 20) {
                    if (map.get(10) > 0 && map.get(5) > 0) {
                        map.set(10, (map.get(10) || 0) - 1)
                        map.set(5, (map.get(5) || 0) - 1)
                    } else if (map.get(5) > 2) {
                        map.set(5, (map.get(5) || 0) - 3)
                    } else {
                        return false
                    }
                }
            }
            return true
        };
        var reconstructQueue = function (people) {
            people.sort((a, b) => a[1] - b[1])
            people.sort((a, b) => b[0] - a[0])
            let n = people.length
            for (let i = 1; i < n; i++) {
                let num = people[i][1]
                people.splice(num, 0, people[i])
                people.splice(i + 1, 1)
            }
            return people
        };
        // 3.22
        var findMinArrowShots = function (points) {
            points.sort((a, b) => a[0] - b[0])
            let result = 1
            for (let i = 1; i < points.length; i++) {
                if (points[i][0] <= points[i - 1][1]) {
                    points[i][1] = Math.min(points[i - 1][1], points[i][1])
                } else {
                    result++
                }
            }
            return result
        };
        var eraseOverlapIntervals = function (intervals) {
            intervals.sort((a, b) => {
                return a[1] - b[1]
            })

            let count = 1
            let end = intervals[0][1]

            for (let i = 1; i < intervals.length; i++) {
                let interval = intervals[i]
                if (interval[0] >= end) {
                    end = interval[1]
                    count += 1
                }
            }

            return intervals.length - count
        };
        var partitionLabels = function (s) {
            let n = s.length
            let map = new Map()
            for (let i = 0; i < n; i++) {
                map.set(s[i], i)
            }
            let res = []
            let left = 0
            let right = 0
            for (let i = 0; i < n; i++) {
                right = Math.max(right, map.get(s[i]))
                if (i == right) {
                    res.push(right - left + 1)
                    left = i + 1
                }
            }
            return res
        };
        var monotoneIncreasingDigits = function (n) {
            const isadd = (num) => {
                for (let i = 1; i < num.length; i++) {
                    if (num[i] < num[i - 1]) {
                        return false
                    }
                }
                return true
            }
            let num = n.toString().split('')
            for (let i = num.length - 1; i >= 0; i--) {
                if (isadd(num)) {
                    return parseInt(num.join(''))
                }
                num[i] = '9'
                if (i != 0) {
                    if (num[i - 1] > 0) {
                        num[i - 1] = (parseInt(num[i - 1]) - 1).toString()
                    } else {
                        num[i - 1] = '0'
                    }
                }
            }
        };
        // 3.23
        var fib = function (n) {
            let dp = []
            dp[0] = 0
            dp[1] = 1
            for (let i = 2; i <= n; i++) {
                dp[i] = dp[i - 1] + dp[i - 2]
            }
            return dp[n]
        };
        var minCostClimbingStairs = function (cost) {
            let dp = []
            let n = cost.length
            dp[0] = 0
            dp[1] = 0
            for (let i = 2; i <= n; i++) {
                dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
            }
            return dp[n]
        };
        var integerBreak = function (n) {
            let dp = []
            dp[2] = 1
            for (let i = 3; i <= n; i++) {
                for (let j = 1; j < i; j++) {
                    dp[i] = Math.max(dp[i], j * (i - j), dp[i - j] * j)
                }
            }
            return dp[n]
        };
        var numTrees = function (n) {
            let dp = new Array(n + 1).fill(0)
            dp[0] = 1
            dp[1] = 1
            dp[2] = 2
            for (let i = 3; i <= n; i++) {
                for (let j = 1; j <= i; j++) {
                    dp[i] += dp[j - 1] * dp[i - j]
                }
            }
            return dp[n]
        };
        var canPartition = function (nums) {
            const sum = (nums.reduce((p, v) => p + v));
            if (sum & 1) return false;
            const dp = Array(sum / 2 + 1).fill(0);
            for (let i = 0; i < nums.length; i++) {
                for (let j = sum / 2; j >= nums[i]; j--) {
                    dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
                    if (dp[j] === sum / 2) {
                        return true;
                    }
                }
            }
            return dp[sum / 2] === sum / 2;
        };
        // 3.24
        var lastStoneWeightII = function (stones) {
            let sum = stones.reduce((p, v) => p + v)
            let dp = new Array(sum / 2 + 1).fill(0)
            for (let i = 0; i < stones.length; i++) {
                for (let j = sum / 2; j >= stones[i]; j--) {
                    dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i])
                }
            }
            return sum - dp[sum / 2] - dp[sum / 2]
        };
        var findTargetSumWays = function (nums, target) {
            const sum = nums.reduce((a, b) => a + b);

            if (Math.abs(target) > sum) {
                return 0;
            }

            if ((target + sum) % 2) {
                return 0;
            }

            const halfSum = (target + sum) / 2;

            let dp = new Array(halfSum + 1).fill(0);
            dp[0] = 1;

            for (let i = 0; i < nums.length; i++) {
                for (let j = halfSum; j >= nums[i]; j--) {
                    dp[j] += dp[j - nums[i]];
                }
            }

            return dp[halfSum];
        };
        var findMaxForm = function (strs, m, n) {
            let dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0))
            let numof0 = 0
            let numof1 = 0
            for (let str of strs) {
                numof0 = 0
                numof1 = 0
                for (let s of str) {
                    if (s == '0') {
                        numof0++
                    } else if (s == '1') {
                        numof1++
                    }
                }
                for (let i = m; i >= numof0; i--) {
                    for (let j = n; j >= numof1; j--) {
                        dp[i][j] = Math.max(dp[i][j], dp[i - numof0][j - numof1] + 1)
                    }
                }
            }
            return dp[m][n]
        };
        var change = function (amount, coins) {
            let dp = new Array(amount + 1).fill(0)
            dp[0] = 1
            for (let i = 0; i < coins.length; i++) {
                for (let j = coins[i]; j <= amount; j++) {
                    dp[j] += dp[j - coins[i]]
                }
                console.log([...dp]);
            }
            return dp[amount]
        };
        // 3.25
        var combinationSum4 = function (nums, target) {
            let dp = new Array(target + 1).fill(0)
            dp[0] = 1
            for (let j = 0; j <= target; j++) {
                for (let i = 0; i < nums.length; i++) {
                    if (j - nums[i] >= 0) {
                        dp[j] += dp[j - nums[i]]
                    }
                }
            }
            return dp[target]
        };
        var coinChange = function (coins, amount) {
            let dp = new Array(amount + 1).fill(10001)
            dp[0] = 0
            for (let i = 0; i < coins.length; i++) {
                for (let j = coins[i]; j <= amount; j++) {
                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1)
                }
                console.log([...dp]);
            }
            return dp[amount] == 10001 ? -1 : dp[amount]
        };
        var numSquares = function (n) {
            // let arr=[]
            // for(let i=0;i<101;i++){
            //     arr[i]=i*i
            // }
            let dp = new Array(n + 1).fill(10001)
            dp[0] = 0
            for (let i = 1; i * i < amount; i++) {
                for (let j = i * i; j <= n; j++) {
                    dp[j] = Math.min(dp[j], dp[j - i * i] + 1)
                }
            }
            return dp[n]
        };
        var wordBreak = function (s, wordDict) {
            let dp = new Array(s.length + 1).fill(false)
            dp[0] = true
            for (let j = 0; j <= s.length; j++) {
                for (let i = 0; i < wordDict.length; i++) {
                    if (j - wordDict[i].length >= 0) {
                        if (s.slice(j - wordDict[i].length, j) === wordDict[i] && dp[j - wordDict[i].length]) {
                            dp[j] = true
                        }
                    }
                }
            }
            return dp[s.length]
        };
        var rob = function (nums) {
            let n = nums.length
            let dp = new Array(n).fill(0)
            dp[0] = nums[0]
            dp[1] = Math.max(nums[0], nums[1])
            for (let i = 2; i < n; i++) {
                dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])
            }
            return dp[n - 1]
        };
        var rob = function (nums) {
            let n = nums.length
            if (n == 0) return 0
            if (n == 1) return nums[0]
            let dp1 = new Array(n - 1).fill(0)
            dp1[0] = nums[0]
            dp1[1] = Math.max(nums[0], nums[1])
            for (let i = 2; i < n - 1; i++) {
                dp1[i] = Math.max(dp1[i - 1], dp1[i - 2] + nums[i])
            }
            let dp2 = new Array(n).fill(0)
            dp2[1] = nums[1]
            dp2[2] = Math.max(nums[1], nums[2])
            for (let i = 3; i < n; i++) {
                dp2[i] = Math.max(dp2[i - 1], dp2[i - 2] + nums[i])
            }
            return Math.max(dp1[n - 2], dp2[n - 1])
        };
        var rob = function (root) {
            const postOrder = (node) => {
                if (!node) return [0, 0]
                const left = postOrder(node.left)
                const right = postOrder(node.right)
                const DoNot = Math.max(left[0], left[1]) + Math.max(right[0], right[1])
                const Do = left[0] + right[0] + node.val
                return [DoNot, Do]
            }
            let res = postOrder(root)
            return Math.max(res[0], res[1])
        };
        // 3.26
        var maxProfit = function (prices) {
            let n = prices.length
            let dp = new Array(n).fill(0).map(() => new Array(5).fill(0))
            dp[0] = [0, -prices[0], 0, -prices[0], 0]
            for (let i = 1; i < n; i++) {
                dp[i][0] = dp[i - 1][0]
                dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1])
                dp[i][2] = Math.max(dp[i - 1][1] + prices[i], dp[i - 1][2])
                dp[i][3] = Math.max(dp[i - 1][2] - prices[i], dp[i - 1][3])
                dp[i][4] = Math.max(dp[i - 1][3] + prices[i], dp[i - 1][4])
            }
            return dp[n - 1][4]
        };
        var maxProfit = function (k, prices) {
            let n = prices.length
            let status = 2 * k + 1
            let dp = new Array(n).fill(0).map(() => new Array(status).fill(0))
            for (let i = 0; i < status; i++) {
                if (i % 2 !== 0) {
                    dp[0][i] = -prices[0]
                }
            }
            for (let i = 1; i < n; i++) {
                dp[i][0] = dp[i - 1][0]
                for (let j = 1; j < status; j++) {
                    if (j % 2 !== 0) {
                        dp[i][j] = Math.max(dp[i - 1][j - 1] - prices[i], dp[i - 1][j])
                    } else {
                        dp[i][j] = Math.max(dp[i - 1][j - 1] + prices[i], dp[i - 1][j])
                    }
                }
            }
            return dp[n - 1][status - 1]
        };
        var maxProfit = function (prices) {
            let n = prices.length
            let dp = new Array(n).fill(0).map(() => new Array(4).fill(0))
            // 0持有 1保持卖出 2当天卖出 3冷冻期
            dp[0][0] = 0 - prices[0]
            for (let i = 1; i < n; i++) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i], dp[i - 1][3] - prices[i])
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3])
                dp[i][2] = dp[i - 1][0] + prices[i]
                dp[i][3] = dp[i - 1][2]
                console.log([...dp[i]]);
            }
            return Math.max(...dp[n - 1])
        };
        var maxProfit = function (prices, fee) {
            let n = prices.length
            let dp = new Array(n).fill(0).map(() => new Array(2).fill(0))
            dp[0][0] = 0 - prices[0]
            // 0持有 1不持有
            for (let i = 1; i < n; i++) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i])
                dp[i][1] = Math.max(dp[i - 1][0] + prices[i] - fee, dp[i - 1][1])
            }
            return Math.max(...dp[n - 1])
        };
        var lengthOfLIS = function (nums) {
            let n = nums.length
            let dp = new Array(n).fill(0)
            for (let i = 1; i < n; i++) {
                for (let j = 0; j < i; j++) {
                    if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            return dp[n - 1]
        };
        // 3.27
        var findLengthOfLCIS = function (nums) {
            // let max=0
            // let len=1
            // for(let i=1;i<nums.length;i++){
            //     if(nums[i]>nums[i-1]){
            //         len++
            //     }else{
            //         len=1
            //     }
            //     max=Math.max(max,len)
            // }
            // return max
            let dp = new Array(nums.length).fill(1)
            let max = 1
            for (let i = 1; i < nums.length; i++) {
                if (nums[i] > nums[i - 1]) {
                    dp[i] = dp[i - 1] + 1
                }
                max = Math.max(max, dp[i])
            }
            return max
        };
        var findLength = function (nums1, nums2) {
            let n1 = nums1.length
            let n2 = nums2.length
            let dp = new Array(n1 + 1).fill(0).map(() => new Array(n2 + 1).fill(0))
            let res = 0
            for (let i = 1; i <= n1; i++) {
                for (let j = 1; j <= n2; j++) {
                    if (nums1[i - 1] == nums2[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1] + 1
                    }
                    res = Math.max(res, dp[i][j])
                }
            }
            return res
        };
        var longestCommonSubsequence = function (text1, text2) {
            let n1 = text1.length
            let n2 = text2.length
            let dp = new Array(n1 + 1).fill(0).map(() => new Array(n2 + 1).fill(0))
            for (let i = 1; i <= n1; i++) {
                for (let j = 1; j <= n2; j++) {
                    if (text1[i - 1] == text2[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1] + 1
                    } else {
                        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
                    }
                }
            }
            return dp[n1][n2]
        };
        var maxUncrossedLines = function (nums1, nums2) {
            let n1 = nums1.length
            let n2 = nums2.length
            let dp = new Array(n1 + 1).fill(0).map(() => new Array(n2 + 1).fill(0))
            for (let i = 1; i <= n1; i++) {
                for (let j = 1; j <= n2; j++) {
                    if (nums1[i - 1] == nums2[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1] + 1
                    } else {
                        dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j])
                    }
                }
            }
            return dp[n1][n2]
        };
        var maxSubArray = function (nums) {
            // 超时 n²
            // let n = nums.length
            // let dp = new Array(n).fill(0)
            // let res = -10001
            // for (let i = 0; i < n; i++) {
            //     for (let j = i; j < n; j++) {
            //         dp[i] += nums[j]
            //         res = res < dp[i] ? dp[i] : res
            //     }

            // }
            // return res

            let n = nums.length
            let dp = new Array(n).fill(0)
            let res = -10001
            dp[0] = nums[0]
            for (let i = 1; i < n; i++) {
                dp[i] = Math.max(dp[i - 1] + nums[i], nums[i])
                res = res < dp[i] ? dp[i] : res
            }
            return res
        };
        var isSubsequence = function (s, t) {
            // if(s.length>t.length)return false
            // let n1=s.length
            // let n2=t.length
            // let dp=new Array(n1+1).fill(0).map(()=>new Array(n2+1).fill(0))
            // for(let i=1;i<=n1;i++){
            //     for(let j=1;j<=n2;j++){
            //         if(s[i-1]==t[j-1]){
            //             dp[i][j]=dp[i-1][j-1]+1
            //         }else{
            //             dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1])
            //         }
            //     }
            // }
            // return dp[n1][n2]==n1

            if (s.length > t.length) return false
            let n1 = s.length
            let n2 = t.length
            let dp = new Array(n2 + 1).fill(0)
            let i = 1
            for (let j = 1; j <= n2; j++) {
                if (s[i - 1] == t[j - 1]) {
                    dp[j] = dp[j - 1] + 1
                    i++
                } else {
                    dp[j] = dp[j - 1]
                }
            }
            return dp[n2] == n1
        };
        // 3.28
        var numDistinct = function (s, t) {
            if (s.length < t.length) return 0
            let n1 = s.length
            let n2 = t.length
            let dp = new Array(n1 + 1).fill(0).map(() => new Array(n2 + 1).fill(0))
            for (let i = 0; i <= n1; i++) {
                dp[i][0] = 1
            }
            for (let i = 1; i <= n1; i++) {
                for (let j = 1; j <= n2; j++) {
                    if (s[i - 1] == t[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
                    } else {
                        dp[i][j] = dp[i - 1][j]
                    }
                }
            }
            return dp[n1][n2]
        };
        var minDistance = function (word1, word2) {
            let n1 = word1.length
            let n2 = word2.length
            let dp = new Array(n1 + 1).fill(0).map(() => new Array(n2 + 1).fill(0))
            for (let i = 0; i <= n1; i++)dp[i][0] = i
            for (let j = 0; j <= n2; j++)dp[0][j] = j
            for (let i = 1; i <= n1; i++) {
                for (let j = 1; j <= n2; j++) {
                    if (word1[i - 1] == word2[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1]
                    } else {
                        dp[i][j] = Math.min(dp[i][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j - 1] + 2)
                    }
                }
            }
            return dp[n1][n2]
        };
        var countSubstrings = function (s) {
            let n = s.length
            let dp = new Array(n).fill(0).map(() => new Array(n).fill(false))
            let res = 0
            for (let j = 0; j < n; j++) {
                for (let i = 0; i <= j; i++) {
                    if (s[i] == s[j]) {
                        if (j - i < 2) {
                            dp[i][j] = true
                        } else {
                            dp[i][j] = dp[i + 1][j - 1]
                        }
                    } else {
                        dp[i][j] = false
                    }
                    res += dp[i][j] == true ? 1 : 0
                }
            }
            return res
        };
        var longestPalindromeSubseq = function (s) {
            let n = s.length
            let dp = new Array(n).fill(0).map(() => new Array(n).fill(0))
            for (let i = 0; i < n; i++)dp[i][i] = 1
            for (let i = n - 1; i >= 0; i--) {
                for (let j = i + 1; j < n; j++) {
                    if (s[i] == s[j]) {
                        dp[i][j] = dp[i + 1][j - 1] + 2
                    } else {
                        dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])
                    }
                }
            }
            return dp[0][n - 1]
        };
        // 3.29
        var merge = function (nums1, m, nums2, n) {
            let i = 0
            let j = 0
            const sorted = new Array(m + n).fill(0)
            while (i < m || j < n) {
                if (i == m) {
                    sorted[i + j] = nums2[j]
                    j++
                } else if (j == n) {
                    sorted[i + j] = nums1[i]
                    i++
                } else if (nums1[i] < nums2[j]) {
                    sorted[i + j] = nums1[i]
                    i++
                } else {
                    sorted[i + j] = nums2[j]
                    j++
                }
            }
            for (let i = 0; i < m + n; i++) {
                nums1[i] = sorted[i]
            }
            return nums1
        };
        var removeElement = function (nums, val) {
            let slow = 0
            let fast = 0
            while (fast < nums.length) {
                if (nums[fast] !== val) {
                    nums[slow] = nums[fast]
                    slow++
                }
                fast++
            }
            return slow
        };
        var removeDuplicates = function (nums) {
            let slow = 0
            let fast = 0
            while (fast < nums.length) {
                if (nums[fast] != nums[slow]) {
                    nums[slow + 1] = nums[fast]
                    slow++
                }
                fast++
            }
            console.log(nums);
            return slow + 1
        };
        var removeDuplicates = function (nums) {
            const n = nums.length;
            if (n <= 2) {
                return n;
            }
            let slow = 2, fast = 2;
            while (fast < n) {
                if (nums[slow - 2] != nums[fast]) {
                    nums[slow] = nums[fast];
                    ++slow;
                }
                ++fast;
            }
            return slow;
        };
        var majorityElement = function (nums) {
            let m = new Map()
            let k = Math.floor(nums.length / 2)
            for (let i = 0; i < nums.length; i++) {
                m.set(nums[i], (m.get(nums[i]) || 0) + 1)
            }
            let res = 0
            m.forEach((value, key) => {
                if (value > k) {
                    res = key
                }
            })
            return res
        };
        var rotate = function (nums, k) {
            // for(let i=0;i<nums.length;i++){
            //     nums.unshift(nums.pop())
            // }
            // return nums
            let n = nums.length
            k = k % n
            let arr = []
            for (let i = n - k; i < n; i++) {
                arr.push(nums[i])
            }
            for (let i = 0; i < n - k; i++) {
                arr.push(nums[i])
            }
            return arr
        };
        var maxProfit = function (prices) {
            // let maxprofit=0
            // for(let i=prices.length-1;i>=0;i--){
            //     for(let j=i-1;j>=0;j--){
            //         maxprofit=Math.max(maxprofit,prices[i]-prices[j])
            //     }
            // }
            // return maxprofit

            let n = prices.length
            let maxpro = 0
            let maxpri = 0
            for (let i = n - 1; i > 0; i--) {
                maxpri = Math.max(maxpri, prices[i])
                maxpro = Math.max(maxpro, maxpri - prices[i - 1])
            }
            return maxpro
        };
        var canJump = function (nums) {
            let rightmost = 0
            for (let i = 0; i < nums.length; i++) {
                if (rightmost >= i) {
                    rightmost = Math.max(rightmost, i + nums[i])
                }
            }
            if (rightmost >= nums.length - 1) return true
            return false
        };
        var jump = function (nums) {
            let n = nums.length
            let dp = new Array(n).fill(n)
            dp[0] = 0
            for (let i = 0; i < n; i++) {
                for (let j = 1; j <= nums[i]; j++) {
                    dp[i + j] = Math.min(dp[i + j], dp[i] + 1)
                }
            }
            return dp[n - 1]
        };
        // 3.30
        var hIndex = function (citations) {
            // let n = citations.length
            // let h=0
            // for (; h <= n; h++) {
            //     let num = 0
            //     for (let i = 0; i < n; i++) {
            //         if (citations[i] >= h) {
            //             num++
            //         }
            //     }
            //     if (num < h) {
            //         return h - 1
            //     }
            // }
            // return h

            let n = citations.length
            citations.sort((a, b) => b - a)
            for (let i = 0; i < n; i++) {
                if (citations[i] < i + 1) {
                    return i
                }
            }
            return n
        };
        var productExceptSelf = function (nums) {
            let n = nums.length
            let leftProduct = new Array(n).fill(1)
            leftProduct[0] = nums[0]
            let rightProduct = new Array(n).fill(1)
            rightProduct[n - 1] = nums[n - 1]
            for (let i = 1; i < n; i++) {
                leftProduct[i] = leftProduct[i - 1] * nums[i]
                rightProduct[n - 1 - i] = rightProduct[n - i] * nums[n - 1 - i]
            }
            let answer = []
            answer[0] = rightProduct[1]
            answer[n - 1] = leftProduct[n - 2]
            for (let i = 1; i < n - 1; i++) {
                answer[i] = leftProduct[i - 1] * rightProduct[i + 1]
            }
            return answer
        };
        var trap = function (height) {
            // let n = height.length
            // let res = 0
            // for (let i = 0; i < n; i++) {
            //     if (height[i] > 0) {
            //         let s = 0
            //         let j = i + 2
            //         for (; j < n; j++) {
            //             // 找到右边第一个大于等于他的
            //             if (height[j] >= height[i]) {
            //                 // 右边第一个处理
            //                 s -= height[i + 1]>height[j]?height[i]:height[i+1]
            //                 s += height[i] * (j - i - 1)
            //                 res += s
            //                 i = j - 1
            //                 break
            //             } else {
            //                 s -= height[j]
            //             }
            //         }
            //         // 没有找到右边第一个大于等于他的 就找右边最大的
            //         if (j == n) {
            //             s = 0
            //             let max = 0
            //             let index = i + 1
            //             for (let k = i + 2; k < n; k++) {
            //                 if (height[k] > max) {
            //                     max = height[k]
            //                     index = k
            //                 }
            //             }
            //             for (let k = i + 1; k < index; k++) {
            //                 // 右边第一个处理
            //                 if(height[k]>max){
            //                     s-=max
            //                 }else{
            //                     s -= height[k]
            //                 }
            //             }
            //             s += height[index] * (index - i - 1)
            //             res += s
            //             i = index - 1
            //         }
            //     }

            // }
            // return res

            const n = height.length;
            if (n == 0) {
                return 0;
            }

            const leftMax = new Array(n).fill(0);
            leftMax[0] = height[0];
            for (let i = 1; i < n; ++i) {
                leftMax[i] = Math.max(leftMax[i - 1], height[i]);
            }

            const rightMax = new Array(n).fill(0);
            rightMax[n - 1] = height[n - 1];
            for (let i = n - 2; i >= 0; --i) {
                rightMax[i] = Math.max(rightMax[i + 1], height[i]);
            }

            let ans = 0;
            for (let i = 0; i < n; ++i) {
                ans += Math.min(leftMax[i], rightMax[i]) - height[i];
            }
            return ans;
        };
        var romanToInt = function (s) {
            let map = new Map([
                ['I', 1],
                ['IV', 4],
                ['V', 5],
                ['IX', 9],
                ['X', 10],
                ['XL', 40],
                ['L', 50],
                ['XC', 90],
                ['C', 100],
                ['CD', 400],
                ['D', 500],
                ['CM', 900],
                ['M', 1000],
            ])
            let res = 0
            let i = 0
            while (i < s.length) {
                if (map.has(s[i] + s[i + 1])) {
                    res += map.get(s[i] + s[i + 1])
                    i += 2
                } else {
                    res += map.get(s[i])
                    i++
                }
            }
            return res
        };
        var lengthOfLastWord = function (s) {
            let arr = s.trim().split(' ')
            return arr[arr.length - 1].length
        };
        var longestCommonPrefix = function (strs) {
            let res = []
            let i = 0
            while (i < strs[0].length) {
                let temp = strs[0][i]
                for (let j = 1; j < strs.length; j++) {
                    if (temp != strs[j][i]) {
                        return res.join('')
                    }
                }
                res.push(temp)
                i++
            }
            return res.join('')
        };
        var convert = function (s, numRows) {
            if (s.length <= numRows || numRows == 1) {
                return s
            }
            let n = s.length
            let num = numRows + numRows - 2
            let t = Math.floor((n - 1) / num) + 1
            let tcol = numRows - 1
            let cols = tcol * (t + 1)
            let arr = new Array(numRows).fill(0).map(() => new Array(cols).fill(0))
            let index = 0
            let res = []
            for (let k = 0; k < t; k++) {
                for (let i = 0; i < numRows; i++) {
                    arr[i][k * tcol] = s[index++]
                }
                for (let i = 0; i < tcol - 1; i++) {
                    arr[numRows - 2 - i][i + k * tcol + 1] = s[index++]
                }
            }
            for (let i = 0; i < numRows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (arr[i][j]) {
                        res.push(arr[i][j])
                    }
                }
            }
            return res.join('')
        };
        var strStr = function (haystack, needle) {
            const n = haystack.length, m = needle.length;
            if (m === 0) {
                return 0;
            }
            const pi = new Array(m).fill(0);
            for (let i = 1, j = 0; i < m; i++) {
                while (j > 0 && needle[i] !== needle[j]) {
                    j = pi[j - 1];
                }
                if (needle[i] == needle[j]) {
                    j++;
                }
                pi[i] = j;
            }
            for (let i = 0, j = 0; i < n; i++) {
                while (j > 0 && haystack[i] != needle[j]) {
                    j = pi[j - 1];
                }
                if (haystack[i] == needle[j]) {
                    j++;
                }
                if (j === m) {
                    return i - m + 1;
                }
            }
            return -1;
        };
        // 4.1
        var fullJustify = function (words, maxWidth) {
            let n = words.length
            let linewordwidth = 0
            let curnum = 0
            let res = []
            let index = 0
            let str = []
            let spacenum = 0
            let spacewidth = 0
            let spacesum = 0
            let extraspace = 0
            while (index < n) {
                linewordwidth = 0
                curnum = 0
                let start = index
                while (index < n && linewordwidth + words[index].length <= maxWidth) {
                    linewordwidth += words[index].length + 1
                    curnum++
                    index++
                }
                str = []
                // 最后一行
                if (index == n) {
                    spacesum = maxWidth - linewordwidth + curnum
                    while (start < n) {
                        str.push(words[start])
                        if (spacesum > 0) {
                            str.push(' ')
                            spacesum--
                        }
                        start++
                    }
                    while (spacesum > 0) {
                        str.push(' ')
                        spacesum--
                    }
                    res.push(str.join(''))
                    break
                }
                // 不是最后一行，只有一个单词
                if (curnum == 1) {
                    spacenum = 1
                    spacewidth = Infinity
                    spacesum = maxWidth - linewordwidth + curnum
                } else {
                    // 不是最后一行，不止一个单词
                    spacenum = curnum - 1
                    spacewidth = Math.floor((maxWidth - linewordwidth + curnum) / (curnum - 1))
                    spacesum = maxWidth - linewordwidth + curnum
                    extraspace = spacesum - spacewidth * spacenum
                }
                while (start < index) {
                    str.push(words[start])
                    if (spacenum > 0) {
                        if (spacesum >= spacewidth) {
                            for (let i = 0; i < spacewidth; i++) {
                                str.push(' ')
                                spacesum--
                            }
                            if (extraspace > 0) {
                                str.push(' ')
                                extraspace--
                            }
                        } else {
                            for (let i = 0; i < spacesum; i++) {
                                console.log('a', str);
                                str.push(' ')
                                console.log('a', str);
                            }
                        }
                    }
                    spacenum--
                    start++
                }
                res.push(str.join(''))
            }
            return res
        };
        var isPalindrome = function (s) {
            let n = s.length
            let t = []
            for (let i = 0; i < n; i++) {
                let charCode = s.charCodeAt(i);
                if ((charCode > 47 && charCode < 58) ||
                    (charCode > 96 && charCode < 123) ||
                    (charCode > 64 && charCode < 91)
                ) {
                    t.push(s[i].toLowerCase())
                }
            }
            // console.log(t);
            n = t.length
            for (let i = 0; i < n / 2; i++) {
                if (t[i] != t[n - 1 - i]) {
                    return false
                }
            }
            return true
        };
        var isSubsequence = function (s, t) {
            // dp是公共子序列长度
            // if (s.length > t.length) return false
            // let n1 = s.length
            // let n2 = t.length
            // let dp = new Array(n1 + 1).fill(0).map(() => new Array(n2 + 1).fill(0))
            // for (let i = 1; i <= n1; i++) {
            //     for (let j = 1; j <= n2; j++) {
            //         if (s[i - 1] == t[j - 1]) {
            //             dp[i][j] = dp[i - 1][j - 1] + 1
            //         } else {
            //             dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
            //         }
            //     }
            // }
            // return dp[n1][n2] == n1

            // if (s.length > t.length) return false
            // let n1 = s.length
            // let n2 = t.length
            // let dp = new Array(n2 + 1).fill(0)
            // let i = 1
            // for (let j = 1; j <= n2; j++) {
            //     if (s[i - 1] == t[j - 1]) {
            //         dp[j] = dp[j - 1] + 1
            //         i++
            //     } else {
            //         dp[j] = dp[j - 1]
            //     }
            // }
            // return dp[n2] == n1

            // 双指针
            let n1 = s.length
            let n2 = t.length
            let i = 0
            let j = 0
            while (j < n2) {
                if (s[i] == t[j]) {
                    i++
                }
                j++
            }
            if (i == n1) return true
            return false
        };
        var twoSum = function (numbers, target) {
            // let left = 0
            // let right = numbers.length - 1
            // 二分查找不成立
            // while (left <= right) {
            //     let mid = Math.floor((right - left) / 2) + left
            //     let sum = numbers[left] + numbers[right]
            //     if (sum == target) {
            //         return [left + 1, right + 1]
            //     } else if (sum<target){
            //         right=mid-1
            //     }else{
            //         left=mid+1
            //     }
            // }
            let left = 0
            let right = numbers.length - 1
            while (left < right) {
                let sum = numbers[left] + numbers[right]
                if (sum == target) {
                    return [left + 1, right + 1]
                } else if (sum < target) {
                    left++
                } else {
                    right--
                }
            }

        };
        var maxArea = function (height) {
            let n = height.length
            let left = 0
            let right = n - 1
            let res = 0
            while (left < right) {
                res = Math.max(res, Math.min(height[left], height[right]) * (right - left))
                if (height[left] < height[right]) {
                    left++
                } else {
                    right--
                }
            }
            return res
        };
        var threeSum = function (nums) {
            let n = nums.length
            nums.sort((a, b) => a - b)
            let l = 0
            let r = n - 1
            let res = []
            for (let i = 0; i < n - 2; i++) {
                if (nums[i] == nums[i - 1]) continue
                l = i + 1
                r = n - 1
                while (l < r) {
                    if (nums[i] + nums[l] + nums[r] == 0) {
                        res.push([nums[i], nums[l], nums[r]])
                        l++
                        r--
                        while (l < r && nums[l] == nums[l - 1]) {
                            l++
                        }
                        while (l < r && nums[r] == nums[r + 1]) {
                            r--
                        }
                    } else if (nums[i] + nums[l] + nums[r] < 0) {
                        l++
                    } else {
                        r--
                    }
                }
            }
            return res
        };
        // 4.03
        var lengthOfLongestSubstring = function (s) {
            let m = new Map()
            let n = s.length
            let i = 0
            let res = 0
            for (let j = 0; j < n; j++) {
                if (m.has(s[j])) {
                    while (s[i] !== s[j]) {
                        m.delete(s[i])
                        i++
                    }
                    // m.delete(s[i])
                    i++
                } else {
                    m.set(s[j], 1)
                    res = Math.max(res, j - i + 1)
                }
            }
            return res
        };
        var findSubstring = function (s, words) {
            // let n = s.length
            // let len = words.length
            // let w = words[0].length
            // let width = len * w
            // let arr = []
            // for (let i = 0; i < n / w; i++) {
            //     arr[i] = s.slice(i * w, (i + 1) * w)
            // }
            // let i = 0
            // let j = 0
            // let m = new Map()
            // let res = []
            // for (let i = 0; i < len; i++) {
            //     m.set(words[i], 1)
            // }
            // while (j < n) {
            //     if (m.size == 0) {
            //         res.push(i * w)
            //         i++
            //         for (let i = 0; i < len; i++) {
            //             m.set(words[i], 1)
            //         }
            //         for (let index = i; index < j; index++) {
            //             m.delete(arr[index])
            //         }
            //     }
            //     if (m.has(arr[j])) {
            //         m.delete(arr[j])
            //         j++
            //     } else {
            //         console.log(m, i, j);
            //         m.clear()
            //         for (let i = 0; i < len; i++) {
            //             m.set(words[i], 1)
            //         }
            //         i++
            //         for (let index = i; index < j; index++) {
            //             m.delete(arr[index])
            //         }
            //         console.log(1,m, i, j);
            //         j++
            //     }
            // }
            // return res

            // 官方题解
            const res = [];
            const m = words.length, n = words[0].length, ls = s.length;
            // 遍历字符串起点
            for (let i = 0; i < n; i++) {
                if (i + m * n > ls) {
                    break;
                }
                const differ = new Map();
                for (let j = 0; j < m; j++) {
                    const word = s.substring(i + j * n, i + (j + 1) * n);
                    differ.set(word, (differ.get(word) || 0) + 1);
                }
                for (const word of words) {
                    differ.set(word, (differ.get(word) || 0) - 1);
                    if (differ.get(word) === 0) {
                        differ.delete(word);
                    }
                }
                // 从起点开始遍历每一个单词，滑动窗口
                for (let start = i; start < ls - m * n + 1; start += n) {
                    if (start !== i) {
                        // 加上下一个
                        let word = s.substring(start + (m - 1) * n, start + m * n);
                        differ.set(word, (differ.get(word) || 0) + 1);
                        if (differ.get(word) === 0) {
                            differ.delete(word);
                        }
                        // 删掉上一个
                        word = s.substring(start - n, start);
                        differ.set(word, (differ.get(word) || 0) - 1);
                        if (differ.get(word) === 0) {
                            differ.delete(word);
                        }
                    }
                    // 如果differ为空，说明字符串刚好是串联子串
                    if (differ.size === 0) {
                        res.push(start);
                    }
                }
            }
            return res;
        };
        // 4.04
        var isValidSudoku = function (board) {
            let m = new Map()
            for (let i = 0; i < 9; i++) {
                m.clear()
                for (let j = 0; j < 9; j++) {
                    if (m.has(board[i][j])) {
                        return false
                    }
                    if (board[i][j] != '.') {
                        m.set(board[i][j], 1)
                    }
                }
            }
            for (let i = 0; i < 9; i++) {
                m.clear()
                for (let j = 0; j < 9; j++) {
                    if (m.has(board[j][i])) {
                        return false
                    }
                    if (board[j][i] != '.') {
                        m.set(board[j][i], 1)
                    }
                }
            }
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    m.clear()
                    for (let x = i * 3; x < i * 3 + 3; x++) {
                        for (let y = j * 3; y < j * 3 + 3; y++) {
                            if (m.has(board[x][y])) {
                                return false
                            }
                            if (board[x][y] != '.') {
                                m.set(board[x][y], 1)
                            }
                        }
                    }
                }
            }
            return true
        };
        var spiralOrder = function (matrix) {
            let m = matrix.length
            let n = matrix[0].length
            let direction = 'right'
            let res = []
            for (let cishu = 0; cishu < n / 2; cishu++) {
                if (direction == 'right') {
                    if (res.length == n * m) break
                    for (let i = cishu; i < n - cishu; i++) {
                        res.push(matrix[cishu][i])
                    }
                    direction = 'down'
                }
                if (direction == 'down') {
                    if (res.length == n * m) break
                    for (let i = cishu + 1; i < m - cishu; i++) {
                        res.push(matrix[i][n - cishu - 1])
                    }
                    direction = 'left'
                }
                if (direction == 'left') {
                    if (res.length == n * m) break
                    for (let i = n - cishu - 1 - 1; i >= cishu; i--) {
                        res.push(matrix[m - cishu - 1][i])
                    }
                    direction = 'up'

                }
                if (direction == 'up') {
                    if (res.length == n * m) break
                    for (let i = m - cishu - 1 - 1; i >= cishu + 1; i--) {
                        res.push(matrix[i][cishu])
                    }
                    direction = 'right'
                }
            }
            return res
        };
        var setZeroes = function (matrix) {
            let m = matrix.length
            let n = matrix[0].length
            let row = []
            let col = []
            for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    if (matrix[i][j] == 0) {
                        row[i] = 0
                        col[j] = 0
                    }
                }
            }
            for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    if (row[i] == 0 || col[j] == 0) {
                        matrix[i][j] = 0
                    }
                }
            }
            return matrix
        };
        // 4.05
        var gameOfLife = function (board) {
            let m = board.length
            let n = board[0].length
            let sumboard = new Array(m).fill(0).map(() => new Array(n).fill(0))
            for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    let sum = 0
                    i > 0 && j > 0 && board[i - 1][j - 1] && sum++
                    i > 0 && board[i - 1][j] && sum++
                    i > 0 && j < n - 1 && board[i - 1][j + 1] && sum++
                    j > 0 && board[i][j - 1] && sum++
                    j < n - 1 && board[i][j + 1] && sum++
                    i < m - 1 && j > 0 && board[i + 1][j - 1] && sum++
                    i < m - 1 && board[i + 1][j] && sum++
                    i < m - 1 && j < n - 1 && board[i + 1][j + 1] && sum++
                    sumboard[i][j] = sum
                }
            }
            for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    if (board[i][j] == 0) {
                        if (sumboard[i][j] == 3) {
                            board[i][j] = 1
                        } else {
                            board[i][j] = 0
                        }
                    } else {
                        if (sumboard[i][j] < 2) {
                            board[i][j] = 0
                        } else if (sumboard[i][j] == 2 || sumboard[i][j] == 3) {
                            board[i][j] = 1
                        } else if (sumboard[i][j] > 3) {
                            board[i][j] = 0
                        }
                    }
                }
            }
            return board
        };
        var isIsomorphic = function (s, t) {
            if (s.length != t.length) return false
            s = Array.from(s)
            t = Array.from(t)
            let m = new Map()
            let index = 0
            for (let i = 0; i < s.length; i++) {
                if (!m.has(s[i])) {
                    m.set(s[i], index++)
                    s[i] = index - 1
                } else {
                    s[i] = m.get(s[i])
                }

            }
            m.clear()
            index = 0
            for (let i = 0; i < t.length; i++) {
                if (!m.has(t[i])) {
                    m.set(t[i], index++)
                    t[i] = index - 1
                } else {
                    t[i] = m.get(t[i])
                }
            }
            for (let i = 0; i < s.length; i++) {
                if (s[i] != t[i]) {
                    return false
                }
            }
            return true
        };
        var wordPattern = function (pattern, s) {
            let m = new Map()
            let m1 = new Map()
            s = s.split(' ')
            for (let i = 0; i < s.length; i++) {
                if (!m.has(s[i])) {
                    if (!m1.has(pattern[i])) {
                        m.set(s[i], 1)
                        m1.set(pattern[i], 1)
                    } else {
                        return false
                    }
                } else {
                    if (!m1.has(pattern[i])) {
                        return false
                    } else {

                    }
                }
            }
            return true
        };
        var twoSum = function (nums, target) {
            let map = new Map();
            for (let i = 0, len = nums.length; i < len; i++) {
                if (map.has(target - nums[i])) {
                    return [map.get(target - nums[i]), i];
                } else {
                    map.set(nums[i], i);
                }
            }
            return [];
        };
        // 4.06
        var containsNearbyDuplicate = function (nums, k) {
            let n = nums.length
            let m = new Map()
            for (let i = 0; i < n; i++) {
                if (m.has(nums[i]) && i - m.get(nums[i]) <= k) {
                    return true
                }
                m.set(nums[i], i)
            }
            return false
        };
        var longestConsecutive = function (nums) {
            let n = nums.length
            let s = new Set(nums)
            let max = 0
            for (let i = 0; i < n; i++) {
                if (!s.has(nums[i] - 1)) {
                    let cur = nums[i]
                    let count = 1
                    while (s.has(cur + 1)) {
                        cur++
                        count++
                    }
                    max = Math.max(max, count)
                }
            }
            return max
        };
        var summaryRanges = function (nums) {
            let n = nums.length
            let res = []
            let i = 0
            while (i < n) {
                let start = nums[i]
                while (i < n && nums[i + 1] == nums[i] + 1) {
                    i++
                }
                let end = nums[i]
                if (start == end) {
                    res.push(start.toString())
                } else {
                    res.push(start + '->' + nums[i])
                }
                i++
            }
            return res
        };
        var merge = function (intervals) {
            let n = intervals.length
            let i = 0
            let res = []
            intervals.sort((a, b) => a[1] - b[1])
            intervals.sort((a, b) => a[0] - b[0])
            while (i < n) {
                let temp = intervals[i]
                while (i < n - 1 && temp[1] >= intervals[i + 1][0]) {
                    temp = [Math.min(temp[0], intervals[i + 1][0]), Math.max(temp[1], intervals[i + 1][1])]
                    i++
                }
                res.push(temp)
                i++
            }
            return res
        };
        var insert = function (intervals, newInterval) {
            const res = [];
            let i = 0;
            const len = intervals.length;

            while (i < len && intervals[i][1] < newInterval[0]) { // 当前遍历的是蓝左边的，不重叠的区间
                res.push(intervals[i]);
                i++;
            }

            while (i < len && intervals[i][0] <= newInterval[1]) { // 当前遍历是有重叠的区间
                newInterval[0] = Math.min(newInterval[0], intervals[i][0]); //左端取较小者，更新给兰区间的左端
                newInterval[1] = Math.max(newInterval[1], intervals[i][1]); //右端取较大者，更新给兰区间的右端
                i++;
            }
            res.push(newInterval); // 循环结束后，兰区间为合并后的区间，推入res

            while (i < len) {                 // 在蓝右边，没重叠的区间
                res.push(intervals[i]);
                i++;
            }

            return res;
        };
        var isValid = function (s) {
            let m = new Map([
                ['(', ')'],
                ['{', '}'],
                ['[', ']'],
            ])
            let stack = []
            for (let i = 0; i < s.length; i++) {
                if (m.has(s[i])) {
                    stack.push(s[i])
                } else {
                    if (m.get(stack[stack.length - 1]) == s[i]) {
                        stack.pop()
                    } else {
                        return false
                    }
                }
            }
            return stack.length == 0
        };
        // 4.09
        var MinStack = function () {
            this.size = 0
            this.a = []
            this.b = []
        };

        /** 
         * @param {number} val
         * @return {void}
         */
        MinStack.prototype.push = function (val) {
            let flag = false
            for (let i = 0; i < this.size; i++) {
                if (val < this.a[i]) {
                    this.a.splice(i, 0, val)
                    flag = true
                    break
                }
            }
            if (!flag) {
                this.a.push(val)
            }
            this.b.push(val)
            this.size++
        };

        /**
         * @return {void}
         */
        MinStack.prototype.pop = function () {
            let val = this.b.pop()
            for (let i = 0; i < this.size; i++) {
                if (this.a[i] == val) {
                    this.a.splice(i, 1)
                }
            }
            this.size--
        };

        /**
         * @return {number}
         */
        MinStack.prototype.top = function () {
            return this.b[this.size - 1]
        };

        /**
         * @return {number}
         */
        MinStack.prototype.getMin = function () {
            return this.a[0]
        };
        //  * Your MinStack object will be instantiated and called as such:
        //  var obj = new MinStack()
        //  obj.push(-2)
        //  obj.push(0)
        //  obj.push(-3)
        //  console.log(obj.getMin())
        // //  console.log(obj)
        //  obj.pop()
        //  console.log(obj.top())
        //  console.log(obj.getMin())

        var calculate = function (s) {
            // 存1和-1 分别是+和-
            const ops = [1];
            let sign = 1;

            // 中间结果
            let ret = 0;
            const n = s.length;
            let i = 0;
            while (i < n) {
                if (s[i] === ' ') {
                    i++;
                } else if (s[i] === '+') {
                    sign = ops[ops.length - 1];
                    i++;
                } else if (s[i] === '-') {
                    sign = -ops[ops.length - 1];
                    i++;
                } else if (s[i] === '(') {
                    ops.push(sign);
                    i++;
                } else if (s[i] === ')') {
                    ops.pop();
                    i++;
                } else {
                    let num = 0;
                    // 获取这个数
                    while (i < n && !(isNaN(Number(s[i]))) && s[i] !== ' ') {
                        num = num * 10 + s[i].charCodeAt() - '0'.charCodeAt();
                        i++;
                    }
                    // 结果加或减这个数
                    ret += sign * num;
                }
            }
            return ret;
        };
        var addTwoNumbers = function (l1, l2) {
            let p1 = l1
            let p2 = l2
            let plus = 0
            let p3 = new ListNode(0)
            let l3 = new ListNode(0, p3)
            let sum = 0
            while (p1 || p2) {
                if (p1 && p2) {
                    sum = p1.val + p2.val
                } else if (!p1) {
                    sum = p2.val
                } else if (!p2) {
                    sum = p1.val
                }
                if (plus == 1) {
                    sum++
                }
                if (sum >= 10) {
                    plus = 1
                    sum -= 10
                } else {
                    plus = 0
                }
                p3.next = new ListNode(sum)
                if (p1) p1 = p1.next
                if (p2) p2 = p2.next
                p3 = p3.next
            }
            if (plus == 1) {
                p3.next = new ListNode(1)
            }
            return l3.next.next
        };
        var reverseBetween = function (head, left, right) {
            let dummy = new ListNode(-1)
            dummy.next = head
            let pre = dummy
            for (let i = 0; i < left - 1; i++) {
                pre = pre.next
            }
            let cur = pre.next
            for (let i = 0; i < right - left; i++) {
                let next = cur.next
                cur.next = next.next
                next.next = pre.next
                pre.next = next
            }
            return dummy.next
        };
        // 4.10
        var removeNthFromEnd = function (head, n) {
            if (!head.next) return null
            let index = 0
            let p = head
            while (p) {
                p = p.next
                index++
            }
            let i = index - n + 1
            p = head
            index = 1
            while (p.next) {
                if (index == i - 1) {
                    p.next = p.next.next
                    break
                }
                p = p.next
                index++
            }
            return head
        };
        // 4.14
        var rotateRight = function (head, k) {
            if (k == 0 || !head || !head.next) {
                return head
            }

            let n = 1
            let cur = head
            while (cur.next) {
                cur = cur.next
                n++
            }

            let add = n - k % n
            if (add == 0) return head
            cur.next = head
            while (add) {
                cur = cur.next
                add--
            }

            let ret = cur.next
            cur.next = null
            return ret
        };
        var partition = function (head, x) {
            let small = new ListNode(-1)
            let large = new ListNode(-1)
            let smallhead = small
            let largehead = large
            let cur = head
            while (cur) {
                if (cur.val < x) {
                    small.next = cur
                    small = small.next
                } else {
                    large.next = cur
                    large = large.next
                }
                cur = cur.next
            }
            small.next = largehead.next
            return smallhead.next
        };
        // 五个树
        // 4.15
        var flatten = function (root) {
            const list = [];
            preorderTraversal(root, list);
            const size = list.length;
            for (let i = 1; i < size; i++) {
                const prev = list[i - 1], curr = list[i];
                prev.left = null;
                prev.right = curr;
            }
        };
        const preorderTraversal = (root, list) => {
            if (root != null) {
                list.push(root);
                preorderTraversal(root.left, list);
                preorderTraversal(root.right, list);
            }
        }
        // 4.18
        // 几个题都直接写力扣上了
        // 4.20
        var dailyTemperatures = function (temperatures) {
            // let n=temperatures.length
            // let answer=[]
            // for(let i=0;i<n;i++){
            //     let flag=false
            //     for(let j=i+1;j<n;j++){
            //         if(temperatures[j]>temperatures[i]){
            //             answer.push(j-i)
            //             flag=true
            //             break
            //         }
            //     }
            //     if(!flag){
            //         answer.push(0)
            //     }
            // }
            // return answer

            // 单调栈
            const n = temperatures.length;
            const res = Array(n).fill(0);
            const stack = [];  // 递增栈：用于存储元素右面第一个比他大的元素下标
            stack.push(0);
            for (let i = 1; i < n; i++) {
                // 栈顶元素
                const top = stack[stack.length - 1];
                if (temperatures[i] < temperatures[top]) {
                    stack.push(i);
                } else if (temperatures[i] === temperatures[top]) {
                    stack.push(i);
                } else {
                    while (stack.length && temperatures[i] > temperatures[stack[stack.length - 1]]) {
                        const top = stack.pop();
                        res[top] = i - top;
                    }
                    stack.push(i);
                }
            }
            return res;
        };
        var nextGreaterElement = function (nums1, nums2) {
            let n = nums1.length
            let m = nums2.length
            let stack = []
            let map = new Map()
            for (let i = 0; i < m; i++) {
                while (stack.length && nums2[i] > nums2[stack[stack.length - 1]]) {
                    let index = stack.pop()
                    map.set(nums2[index], nums2[i])
                }
                stack.push(i)
            }
            let res = []
            for (let i = 0; i < n; i++) {
                res[i] = map.get(nums1[i]) || -1
            }
            return res
        };
        var nextGreaterElements = function (nums) {
            let len=nums.length
            let stack=[]
            let res=new Array(len).fill(-1)
            for(let i=0;i<len*2;i++){
                while(stack.length&&nums[i%len]>nums[stack[stack.length-1]]){
                    let index=stack.pop()
                    res[index]=nums[i%len]
                }
                stack.push(i%len)
            }
            return res
        };
        // console.log(isValid("()[]{}(}"));
    </script>
</head>

<body>
    <!--  -->
</body>

</html>